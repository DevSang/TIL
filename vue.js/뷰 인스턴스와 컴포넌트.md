## 03 뷰 인스턴스와 컴포넌트



### 03-01 뷰 인스턴스



#### 뷰 인스턴스?

뷰 인스턴스는 뷰로 화면을 개발하기 위해 필수적으로 생성해야 하는 기본단위이다.



#### 뷰 인스턴스의 생성

new Vue() 인 Vue생성자를 통해 뷰 인스턴스를 생성한다.

```
<script>
	new Vue({
        el:'#app',
        data : {
            message: 'hello vue.js'
        }
	});
</script>
```



#### 뷰 인스턴스 옵션 속성

- el : 뷰로 만든 화면이 그려지는 시작점을 의미한다. 뷰 인스턴스로 화면을 렌더링할 때 화면이 그려질 위치의 돔 요소를 지정해주어야 한다. 이때, css선택자를 따른다.
- data : 뷰 인스턴스가 가지고 있는 데이터를 정의하는 속성이다.
- template : 화면에 표시할 마크업 요소를 정의하는 속성이다.
- methods : 화면 로직 젱와 관계된 메서드를 정의하는 속성이다.
- created : 뷰 인스턴스가 생성되자마자 실행할 로직을 정의할 수 있는 속성이다.



> 마크업 언어? 태그 등을 이용하여 문서나 데이터의 구조를 명기하는 언어의 한 가지이다. 



#### 뷰 인스턴스의 유효 범위

인스턴스의 유효 범위는 el 속성으로 지정한 태그 아래에 오는 요소들로 제한된다.



#### 뷰 인스턴스 라이프 사이클

 

![뷰 인스턴스 라이프 사이클](https://img1.daumcdn.net/thumb/R720x0.q80/?scode=mtistory2&fname=http%3A%2F%2Fcfile8.uf.tistory.com%2Fimage%2F994C103B5A7878FE221AFE)

- beforeCreate :  가장 처음 실행되는 라이프 사이클 단계이다. data, methods 속성이 아직 정의되어 있지 않고, 돔과 같은 화면 요소에도 접근할 수 없다.
- created : data, methods 속성이 정의 되었기 때문에 다양한 로직을 실행할 수 있지만, 인스턴스가 화면에 부착되기 전이기 때문에 template 속성에 정의된 돔 요소로 접근할 수 없다. 서버에 데이터를 요청하여 받아오는 로직(fetch)을 수행하기에 가장 좋다.
- beforeMount : template 속성에서 지정한 마크업 속성을 render() 통해 변환 후에 el 속성서 지정한 돔요소에 인스턴스를 부착되기 전에 호출된다. 
- mounted : 인스턴스가 부착되고 호출되는 단계로, template 속성에서 정의한 돔에 접근하여 화면요소를 제어하는 로직을 수행하기 좋은 단계이다.
- beforeUpdate : 뷰의 반응성을 제공하기 위해 $watch 속성으로 변화를 감시한다. 데이터가 변경되면 가상 돔으로 화면을 다시 그리기 전에 호출되는 단계이다. 
- updated : 데이터가 변경되고 나서 가상 돔으로 다시 화면을 그리고 나면 실행되는 단계이다. 무한루프의 위험이 있기 때문에 데이터 값을 갱신하는 로직은 가급적 beforeUpdate, 돔 관련된 로직은 update에 추가하는게 좋다.

- beforeDestroy : 뷰 인스턴스가 파괴되기 직전에 호출되는 단계로써, 아직 인스턴스에 접근 할 수 있어 뷰 인스턴스의 데이터를 삭제하기 좋은 단계이다.
- destroyed : 인스턴스의 모든 속성과 하위 인스턴스가 파괴되고 호출되는 단계이다.



>뷰 반응성? 뷰의 특징 중 하나로, 코드의 변화에 따라 화면이 반사적으로 반응하여 빠르게 화면을 갱신하는 것을 의미한다.



### 03-02 뷰 컴포넌트



#### 뷰 컴포넌트?

뷰 컴포넌트란 조합하여 화면을 구성할 수 있는 블록(화면의 특정 영역)을 의미한다. 

컴포넌트를 활용하면 화면을 빠르게 구조화하여 일괄적인 패턴으로 개발 할 수 있다.

![컴포넌트로 구분한 화면 영역 간의 관계도](https://k.kakaocdn.net/dn/dqEVK7/btqxqJyKeZE/rjjGsviTbIdiDoZ3BGv2Qk/img.png)

#### 컴포넌트 등록하기



##### 전역 컴포넌트

여러 인스턴스에서 공통으로 사용할 수 있는 컴포넌트 이다. 

Vue 생성자에서 .component()를 호출하여 다음과 같이 수행하면 전역 컴포넌트를 생성할 수 있다.

```
<body>
	<div id="app>
		<my-component></my-component>
	</div>
	<script>
		Vue.component('my-component',{
            template : '<div>전역 컴포넌트가 등록되었습니다!</div>'
		});
	</script>
</body>
```



##### 지역 컴포넌트

특정 인스턴스에서만 유효한 범위를 갖는 컴포넌트 이다. 

인스턴스에 components 속성을 추가하고 등록할 컴포넌트 이름과 내용을 정의하면 생성이 가능하다.

```
<div id="app>
	<my-component></my-component>
</div>
<script>
	var cmp = {
		template : <div>지역 컴포넌트가 등록되었습니다!</div>
	};
		
	new Vue({
		el : '#app',
        coponents : {
        	'my-component' : cmp
        }
    });
</script>
```



##### 지역 컴포넌트와 전역 컴포넌트의 차이

전역 컴포넌트와 달리, 지역 컴포넌트의 유효 범위는 해당 인스턴스의 영역으로 제한된다. 

반대로 전역 컴포넌트는 모든 인스턴스에서 사용이 가능하므로 유효 범위 또한 제한되지 않는다.



### 03-03 뷰 컴포넌트 통신



#### 컴포넌트 간 통신과 유효 범위

컴포넌트마다 자체적으로 고유한 유효 범위(Scope)를 가지기 때문에 같은 웹 페이지라도 데이터를 공유할 수 없다. 

하지만 이로인해 뷰에서 미리 정의해 놓은 데이터 전달 방식에 따라서  일관된 구조로 어플리케이션을 작성할 수 있다.



#### 상,하위 컴포넌트 관계

 상위-하위 컴포넌트란 컴포넌트 간의 관계가 부모,자식으로 이루어진 컴포넌트 구조를 의미한다. 

상위 컴포넌트에서 하위로는 props라는 특별한 속성을 전달하도록 되어있고, 하위 컴포넌트에서 상위 컴포넌트로는 이벤트만 전달하도록 되어있다.

![상,하위 컴포넌트 간의 통신 방식](https://lh3.googleusercontent.com/-jp3bkdECwSA/WzIB5uT6IkI/AAAAAAAAFQ4/ql5rc2O7ggg-d-LCCCQubvtJjQS7UphggCHMYCw/image_thumb%255B1%255D?imgmax=800)





#### 상위에서 하위 컴포넌트로 데이터 전달하기

props속성은 상위 컴포넌트에서 하위 컴포넌트로 데이터를 전달할 때 사용하는 속성이다.

v-bind 속성으로 하위 컴포넌트의 props 속성을 지정하고 속성 값으로 하위 컴포넌트에 전달할 상위 컴토넌트의 data 속성을 지정한다.

```
<div id="app">
	<child-coponent v-bind:propsdata="message"></child-component>
</div>
<script>
	Vue.component('child-component',{
        props: ['propsdata'],
        template: '<p>{{ propsdata }}</p>',
	});
	
	new Vue({
        el: '#app',
        data: {
            message: 'hello vue! passed from Parent Component'
        }
	});
</script>
```

> 왜 props 에서는 {} 가 아닌 []를 사용할까?



> 딱히 상위 컴포넌트를 지정하지 않은 이유는 뭘까? 컴포넌트를 등록함과 동시에 뷰 인스턴스 자체가 상위 컴포넌트가 되기 때문이다.



#### 하위에서 상위 컴포넌트로 이벤트 전달하기

$emit() 함수는 하위 컴포넌트에서 상위 컴포넌트로 이벤트를 발생시킬때 사용하는 함수이다.

v-on: 속성에 $emit()으로 호출한 이벤트 지정하고 속성 값으로 호출될 상위 컴포넌트의 메서드를 지정한다.

```
<div id="app">
	<child-coponent v-on:show-log="printText"></child-component>
</div>
<script>
	Vue.component('child-component',{
        template: '<button v-on:click="showLog">show</button>',
        methods: {
            showLog: function(){
                this.$emit('show-log');
            }
        }
	});
	
	new Vue({
        el: '#app',
        methods: {
            printText : function(){
                console.log("received an event");
            }
        }
	});
</script>
```



#### 같은 레벨의 컴포넌트 간 통신

같은 레벨의 컴포넌트 간의 통신 방법은 공통 상위 컴포넌트로 이벤트를 전달 한 후 공통 상위 컴포넌트에서 2개의 하위 컴포넌트에 props를 내려 보내야 한다.

하지만 이 방법은 강제로 상위 컴포넌트를 두어야하기 때문에 이를 위해 이벤트 버스가 생겼다.



#### 관계 없는 컴포넌트 간 통신 - 이벤트 버스

이벤트 버스(Event Bus)는 개발자가 지정한 2개의 컴포넌트 간에 데이터를 주고받을 수 있는 방법이다. 

이벤트 버스를 이용하면 상위-하위 관계를 유지하고 있지 않아도 데이터를 전달할 수 있다.



##### 이벤트 버스 구현

어플리케이션 로직을 담는 인스턴스와는 별개로 새로운 인스턴스 1개를 생성하고, 새 인스턴스를 이용하여 이벤트를 보내고 받는다.

```
<div id="app">
	<child-coponent></child-component>
</div>
<script>
	 var eventBus = new Vue();
	 Vue.component('child-component',{
        template: '<div>하위 컴포넌트 영역입니다.<button v-		on:click="showLog'>show</button></div>,
        methods: {
            showLog: function(){
                eventBus.$emit('triggerEventBus',100);
            }
        }
	});
	
	new Vue({
        el: '#app',
        created: function(){
            eventBus.$on('triggerEventBUs',function(value){
                console.Log("이벤트로 전달받은 값: ",value);
            });
        }
	});
</script>
```

이벤트 버스를 잘 활용하면 props 속성을 이용하지 않고도 원하는 컴포넌트 간에 직접적으로 데이터를 전달할 수 있어 편리하지만 컴포넌트가 많아지면 관리가 되지 않는 문제가 발생한다.

이를 위해 뷰엑스(Vuex)라는 상태 관리 도구가 필요하다.