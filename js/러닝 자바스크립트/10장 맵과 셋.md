## 	10장 맵과 셋



### 1. 맵

- 키와 값을 연결하기 위해 사용하던 객체는 다음과 같은 문제가 있다.
  - 프로토타입 체인 때문에 의도치 않은 연결이 생길 수 있다.
  - 연결된 키와 값이 몇개가 되는지 알 수 없다.
  - 키는 반드시 문자열이나 심볼이어야 한다.
  - 프로퍼티의 순서를 보장하지 않는다.
- 맵은 위의 문제를 해결하는 할 수 있는 데이터 구조이다.

```javascript
const u1 = { name: 'cynthia' };
const u2 = { name: 'jackson'};
const u3 = { name: 'olive' };
const u4 = { name: 'jemes' };

const userRoles = new Map();
userRoles.set(ul, 'user');
userRoles.set(u2, 'user');
userRoles.set(u3, 'admin');


//체인으로 연결할 수 있다.
userRoles.set(ul, 'user')
				 .set(u2, 'user')
         .set(u3, 'admin')
         .set(u4, 'admin')

//배열 형태로 넘길 수 있다.
const userRoles = new Map(){
[u1, 'user'],
[u,2, 'user'],
[u3, 'admin'],
[u4, 'admin']
}

userRoles.delete(u4);  //u4 요소 삭제
userRoles.get(u2); //'user'
userRoles.has(u1);  //true
userRoles.has(u4);  //false
userRoles.get(u4);  //undefined
userRoles.size;  //3
userRoles.clear();  //요소 모두 지우기

```

- `keys()` 메서드는 맵의 키를 `values()` 메서드는 값을 `entries` 메서드는 첫 번째 요소가 키이고 두번째 요소가 값인 배열을 각각 반환한다. 
- 모두 이터러블 객체이므로 `for of`	를 쓸 수 있다.

```javascript
for(let i of userRoles.keys()) {
	console.log(i.name) //cynthia jackson olive
}

for(let i of userRoles.values()) {
	console.log(i)  //user user admin
}

for(let [u,r] of userRoles.entries()) {
	console.log(`${u.name} ${r} , `) //cynthia user, jackson user, olive admin
}
```



### 2. 위크맵

- 맵에서 아래의 차이가 추가된 자료구조이다.
  - 키는 반드시 객체이어야 한다.
  - 키는 가비지 콜렉션의 대상이다.
  - 이러러블 객체가 아니며 `clear()` 또한 사용할 수 없다.

- 객체나 맵의 경우 키값을 참조하고 있는 값이 사라져도, 객체나 맵이 메모리의 남아 있다면 키값 여전히 메모리에 남아있다는 문제점이 있다.

```javascript
let john = { name: "John" };

let map = new Map();
map.set(john, "user");

john = null; //참조를 null로 덮어씀.

//john을 나타내는 객체는 맵 안에 저장되어있다.
for(let obj of map.keys()){
  console.log(JSON.stringify(obj));  //{ name: "John" }
}

console.log(map.size); //1
```

- 하지만 위크맵의 경우, 키로 사용된 객체를 참조하는 값이 사라지면 해당 객체는 위크맵에서 자동으로 사라진다.

```javascript
let john = { name: "John" };

let weakMap = new WeakMap();
weakMap.set(john, "user");

john = null; //참조를 덮어씀.

// john을 나타내는 객체는 이제 메모리에서 지워진다.
console.log(weakMap.size); //0
```

- 위크맵은 객체에 데이터를 추가해줘야 하는데, 추가해 줄 데이터는 객체가 살아있는 동안에만 유효한 상황일 때에 유용하다.

```javascript
weakMap.set(john, "비밀문서");
// john이 사망하면, 비밀문서는 자동으로 파기된다.
```

- 특히 캐싱에도 유용하다. 동일한 함수를 여러 번 호출해야 할 때, 최초 호출 시 반환된 값을 어딘가에 저장해 놓았다가 그다음엔 함수를 호출하는 대신 저장된 값을 사용하도록 하는데에 유용하다.

```javascript
let cache = new WeakMap();

function sayHi() {
	return 'hi';
}

// 연산을 수행하고 그 결과를 위크맵에 저장한다.
function process(obj) {
  if (!cache.has(obj)) {
    let result = obj();

    cache.set(obj, result);
  }

  return cache.get(obj);
}

let result = process(sayHi);

// 객체가 쓸모없어지면 아래와 같이 null로 덮어쓴다.
sayHi = null;

```



### 3. 셋

- 중복을 허용하지 않는 데이터 집합이다.

```javascript
const roles = new Set();
roles.add('user'); //['user']
roles.add('admin');  //['user', 'admin']
roles.size(); //2
roles.add('user'); //['user', 'admin']
roles.size(); //2
roles.delete('admin');  //['user']
roles.size(); //1
```



### 4. 위크셋

- 셋에서 아래의 차이가 추가된 자료구조이다.
  - 요소는 객체만 가능하다.
  - 이 객체들은 가비지 콜렉션의 대상이다.
  - 이러러블 객체가 아니며 `clear()` 또한 사용할 수 없다.
  - <del>위크맵과 아주 비슷하쥬?</del>

```javascript
const naughty = new WeakSet();

const children = [
	{name: 'suzy'},
	{name: 'derek'}
]

naughty.add(children[1]);

for(let child of children) {
	if(naughty.has(child)) {
		console.log(`Coal for ${child.name}`);
	} else {
		console.log(`Presents for ${child.name}`);
	}
}
```



- 아래 사이트를 참고하였다. [위크맵과 위크셋](https://ko.javascript.info/weakmap-weakset)

