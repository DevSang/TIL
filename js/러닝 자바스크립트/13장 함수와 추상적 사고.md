## 13장 함수의 추상적 사고



### 13.1 서브루틴으로서의 함수

- 서브루틴 : 반복되는 작업의 일부를 떼어내서 이름을 붙이고, 언제든 그 이름을 부르기만 하면 실행되는 작업의 단위

```javascript
const printLeapYearStatus() {
  const year = new Date().getFullYear();
  if (year % 4 !== 0) console.log(`${year} is NOT a leap year`)
  else if (year % 100 != 0) console.log(`${year} IS a leap year`)
  else if (year % 400 != 0) console.log(`${year} is NOT a leap year`)
  else console.log(`${year} IS a leap year`)
}
```



### 13.2 값을 반환하는 서브루틴으로서의 함수

```javascript
const isCurrentLeapYear() {
  const year = new Date().getFullYear();
  if (year % 4 !== 0) return false;
  else if (year % 100 != 0) return true;
  else if (year % 400 != 0) return false;
  else return true;
}
```



### 13.3 순수 함수로서의 함수

- 순수함수 : 입력이 같으면 결과도 같으며, 부수효과가 존재하지 않는 함수
- `클로저`를 이용해서 부수효과를 사라지게 할 수 있다.

```javascript
//수정 전
const colors = ['red', 'yellow', 'orange'];
let colorIndex = 1;
function getNextColor() {
  if (++colorIndex >= color.length) colorIndex = 0;
  return colors[colorIndex];
}

//1차 수정 후
const getNextColor = (function() {
  const colors = ['red', 'yellow', 'orange'];
	let colorIndex = 1;
  return function() {
    if (++colorIndex >= color.length) colorIndex = 0;
  	return colors[colorIndex];
  }
})();
```

- 위 코드는 부수효과가 없어졌지만, 입력은 같아도 출력이 다를 수 있기 때문에 순수함수는 아니다. `이터레이터`를 이용해서 같은 출력을 나게 하도록 변경 할 수 있다.

```javascript
//2차 수정후
function getNextColor() {
  const colors = ['red', 'yellow', 'orange'];
	let colorIndex = 1;
  return {
    next() {
    	if (++colorIndex >= color.length) colorIndex = 0;
  		return colors[colorIndex];
    }
  };
}
```

- 위 코드는 부수효과도 없으며 항상 같은 출력(이터레이터)를 반환하기 때문에 순수함수이다.
- 여기서 중요한 부분!
  - 결국 `next()` 메서드는 매번 다른 값을 반환하므로 문제를 뒤로 미뤘다고 생각할 수 있다.
  - 여기서 우리는 `next()` 가 함수가 아니라 메서드라는 것을 주목해야 한다.
  - 메서드는 자신이 속한 객체라는 컨텍스트 안에서 동작하므로 메서드의 동작은 그 객체에 의해 좌우된다.
  - 따라서 다른 프로그램에서 호출하더라도 독립적인 이터레이터가 생성되므로 다른 이터레이터를 간섭하지 않는다.



### 13.4 그래서?

- 필자는 순수한 함수를 권장. 항상 순수한 함수를 쓰는 습관을 들이도록 노력
- 왜? 코드를 테스트하기 쉽고, 이해하기 쉽고, 재사용하기 쉬우니까



### 13.4.1 함수도 객체다

- 자바스크립트 함수는 `Function` 객체의 인스턴스이다.

```javascript
function a() {}

console.log(typeof a); //function
console.log(a instanceof Function); //true
console.log(a instanceof Object); //true
```

 

### 13.5 IIFE와 비동기적 코드



